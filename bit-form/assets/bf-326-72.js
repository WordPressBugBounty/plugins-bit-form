var Le=Object.defineProperty,Oe=Object.defineProperties;var me=Object.getOwnPropertyDescriptors;var ue=Object.getOwnPropertySymbols;var ke=Object.prototype.hasOwnProperty,_e=Object.prototype.propertyIsEnumerable;var ce=(t,n,e)=>n in t?Le(t,n,{enumerable:!0,configurable:!0,writable:!0,value:e}):t[n]=e,G=(t,n)=>{for(var e in n||(n={}))ke.call(n,e)&&ce(t,e,n[e]);if(ue)for(var e of ue(n))_e.call(n,e)&&ce(t,e,n[e]);return t},oe=(t,n)=>Oe(t,me(n));var le=(t,n,e)=>new Promise((d,b)=>{var S=E=>{try{v(e.next(E))}catch(C){b(C)}},h=E=>{try{v(e.throw(E))}catch(C){b(C)}},v=E=>E.done?d(E.value):Promise.resolve(E.value).then(S,h);v((e=e.apply(t,n)).next())});import{a$ as Fe,ch as ye,ci as Ne,cj as Me,ck as qe,r as R,cl as xe,cm as u,cn as We,co as pe,cp as fe,cq as de,cr as y,cs as Pe,ct as K,cu as Ue,cv as he,cw as He,cx as Re,cy as je,c as ze,cz as Ge}from"./main-232.js";const Ee=Fe.use||(t=>{if(t.status==="pending")throw t;if(t.status==="fulfilled")return t.value;throw t.status==="rejected"?t.reason:(t.status="pending",t.then(n=>{t.status="fulfilled",t.value=n},n=>{t.status="rejected",t.reason=n}),t)}),Y={dedupe:!0},Ke=(t,n,e)=>{const{cache:d,compare:b,suspense:S,fallbackData:h,revalidateOnMount:v,revalidateIfStale:E,refreshInterval:C,refreshWhenHidden:$,refreshWhenOffline:B,keepPreviousData:Se}=e,[N,ve,w,De]=Me.get(d),[s,J]=qe(t),W=R.useRef(!1),k=R.useRef(!1),M=R.useRef(s),p=R.useRef(n),P=R.useRef(e),c=()=>P.current,U=()=>c().isVisible()&&c().isOnline(),[A,H,Te,Ve]=xe(d,s),_=R.useRef({}).current,be=u(h)?e.fallback[s]:h,Q=(a,r)=>{for(const l in _){const i=l;if(i==="data"){if(!b(a[i],r[i])&&(!u(a[i])||!b(x,r[i])))return!1}else if(r[i]!==a[i])return!1}return!0},X=R.useMemo(()=>{const a=(()=>!s||!n?!1:u(v)?c().isPaused()||S?!1:u(E)?!0:E:v)(),r=f=>{const T=je(f);return delete T._k,a?G({isValidating:!0,isLoading:!0},T):T},l=A(),i=Ve(),D=r(l),m=l===i?D:r(i);let o=D;return[()=>{const f=r(A());return Q(f,o)?(o.data=f.data,o.isLoading=f.isLoading,o.isValidating=f.isValidating,o.error=f.error,o):(o=f,f)},()=>m]},[d,s]),I=We.useSyncExternalStore(R.useCallback(a=>Te(s,(r,l)=>{Q(l,r)||a()}),[d,s]),X[0],X[1]),Z=!W.current,Ce=N[s]&&N[s].length>0,L=I.data,O=u(L)?be:L,q=I.error,ee=R.useRef(O),x=Se?u(L)?ee.current:L:O,te=(()=>Ce&&!u(q)?!1:Z&&!u(v)?v:c().isPaused()?!1:S?u(O)?!1:E:u(O)||E)(),se=!!(s&&n&&Z&&te),we=u(I.isValidating)?se:I.isValidating,Ae=u(I.isLoading)?se:I.isLoading,F=R.useCallback(a=>le(void 0,null,function*(){const r=p.current;if(!s||!r||k.current||c().isPaused())return!1;let l,i,D=!0;const m=a||{},o=!w[s]||!m.dedupe,f=()=>Re?!k.current&&s===M.current&&W.current:s===M.current,T={isValidating:!1,isLoading:!1},ae=()=>{H(T)},re=()=>{const g=w[s];g&&g[1]===i&&delete w[s]},ie={isValidating:!0};u(A().data)&&(ie.isLoading=!0);try{if(o&&(H(ie),e.loadingTimeout&&u(A().data)&&setTimeout(()=>{D&&f()&&c().onLoadingSlow(s,e)},e.loadingTimeout),w[s]=[r(J),pe()]),[l,i]=w[s],l=yield l,o&&setTimeout(re,e.dedupingInterval),!w[s]||w[s][1]!==i)return o&&f()&&c().onDiscarded(s),!1;T.error=fe;const g=ve[s];if(!u(g)&&(i<=g[0]||i<=g[1]||g[1]===0))return ae(),o&&f()&&c().onDiscarded(s),!1;const V=A().data;T.data=b(V,l)?V:l,o&&f()&&c().onSuccess(l,s,e)}catch(g){re();const V=c(),{shouldRetryOnError:j}=V;V.isPaused()||(T.error=g,o&&f()&&(V.onError(g,s,V),(j===!0||de(j)&&j(g))&&(!c().revalidateOnFocus||!c().revalidateOnReconnect||U())&&V.onErrorRetry(g,s,V,Ie=>{const z=N[s];z&&z[0]&&z[0](y.ERROR_REVALIDATE_EVENT,Ie)},{retryCount:(m.retryCount||0)+1,dedupe:!0})))}return D=!1,ae(),!0}),[s,d]),ne=R.useCallback((...a)=>Pe(d,M.current,...a),[]);if(K(()=>{p.current=n,P.current=e,u(L)||(ee.current=L)}),K(()=>{if(!s)return;const a=F.bind(fe,Y);let r=0;const i=Ue(s,N,(D,m={})=>{if(D==y.FOCUS_EVENT){const o=Date.now();c().revalidateOnFocus&&o>r&&U()&&(r=o+c().focusThrottleInterval,a())}else if(D==y.RECONNECT_EVENT)c().revalidateOnReconnect&&U()&&a();else{if(D==y.MUTATE_EVENT)return F();if(D==y.ERROR_REVALIDATE_EVENT)return F(m)}});return k.current=!1,M.current=s,W.current=!0,H({_k:J}),te&&(u(O)||he?a():He(a)),()=>{k.current=!0,i()}},[s]),K(()=>{let a;function r(){const i=de(C)?C(A().data):C;i&&a!==-1&&(a=setTimeout(l,i))}function l(){!A().error&&($||c().isVisible())&&(B||c().isOnline())?F(Y).then(r):r()}return r(),()=>{a&&(clearTimeout(a),a=-1)}},[C,$,B,s]),R.useDebugValue(x),S&&u(O)&&s){if(!Re&&he)throw new Error("Fallback data is required when using suspense in SSR.");p.current=n,P.current=e,k.current=!1;const a=De[s];if(!u(a)){const r=ne(a);Ee(r)}if(u(q)){const r=F(Y);u(x)||(r.status="fulfilled",r.value=!0),Ee(r)}else throw q}return{mutate:ne,get data(){return _.data=!0,x},get error(){return _.error=!0,q},get isValidating(){return _.isValidating=!0,we},get isLoading(){return _.isLoading=!0,Ae}}},Ye=Ne(Ke),$e=t=>(n,e,d)=>(d.revalidateOnFocus=!1,d.revalidateIfStale=!1,d.revalidateOnReconnect=!1,t(n,e,d)),Be=ye(Ye,$e),ge=t=>{var n;return(t==null?void 0:t.success)&&!((n=t==null?void 0:t.data)!=null&&n.errors)&&!Ge(t.data)},Xe=(t,n,e={})=>{const b=("fetchCondition"in e?e.fetchCondition:!0)?t:null,S=Be(b,h=>{const v=ze(n,Array.isArray(h)?h[0]:h);return e.onLoading&&S.isLoading&&e.onLoading(),v},oe(G({},e),{onSuccess:h=>e.onSuccess&&ge(h)&&e.onSuccess(h.data)}));return R.useEffect(()=>{if(!ge(S.data))return;const{data:h}=S.data;e.onMount?e.onMount(h):e.onSuccess&&e.onSuccess(h)},[]),S};export{Xe as u};
